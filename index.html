<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GenZ Battle (Firebase + WebRTC)</title>
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat SDK (used for simple browser usage + Firestore signaling) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

  <style>
    body { background: radial-gradient(circle at top, #052235, #021726); font-family: 'Poppins', sans-serif }
    .glass { background: rgba(255,255,255,0.04); backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,0.06) }
    .neon { box-shadow: 0 6px 24px rgba(59,130,246,0.18) }
    video { background: #000; border-radius: 12px; }
  </style>
</head>
<body class="min-h-screen flex flex-col text-white">

  <!-- Top bar -->
  <header class="flex items-center gap-3 p-4">
    <button id="homeBtn" class="p-2 rounded-full bg-white/5 hover:bg-white/10 transition">
      <img src="https://img.icons8.com/ios-filled/24/ffffff/home.png" alt="home">
    </button>
    <div class="flex-1">
      <input id="search" placeholder="Search" class="w-full px-4 py-2 rounded-lg bg-white/5 placeholder-gray-300 focus:outline-none" />
    </div>
    <div class="flex items-center gap-2">
      <button id="authBtn" class="px-3 py-2 rounded-lg bg-gradient-to-r from-cyan-500 to-blue-500 hover:scale-105 transition">Login with Google</button>
      <img id="userAvatarSmall" src="" alt="avatar" class="w-10 h-10 rounded-full hidden"/>
    </div>
  </header>

  <!-- Main player card -->
  <main class="flex-1 flex items-center justify-center p-6">
    <div id="sessionCard" class="w-full max-w-4xl p-6 rounded-xl glass neon">

      <div class="flex items-center justify-between">
        <!-- Player 1 -->
        <div class="flex flex-col items-center">
          <div class="p-1 rounded-full bg-gradient-to-tr from-pink-500 to-purple-500">
            <img id="player1Avatar" src="https://img.icons8.com/color/96/user-male-circle--v1.png" class="w-20 h-20 rounded-full" />
          </div>
          <div id="player1Name" class="mt-2 font-semibold">Player 1</div>
        </div>

        <!-- center -->
        <div class="flex flex-col items-center">
          <img src="https://img.icons8.com/fluency/48/flash-on.png" alt="logo" />
        </div>

        <!-- Player 2 -->
        <div class="flex flex-col items-center">
          <div class="p-1 rounded-full bg-gradient-to-tr from-blue-500 to-green-500">
            <img id="player2Avatar" src="https://img.icons8.com/color/96/user-male-circle--v1.png" class="w-20 h-20 rounded-full" />
          </div>
          <div id="player2Name" class="mt-2 font-semibold">Player 2</div>
        </div>
      </div>

      <!-- Join Button -->
      <div class="mt-6 space-y-3">
        <button id="joinBtn" class="w-full py-3 text-lg font-bold bg-gradient-to-r from-blue-600 to-indigo-600 rounded-lg hover:scale-105 transition">JOIN NOW</button>
        <div class="flex items-center justify-center gap-4">
          <button id="vote1" class="px-4 py-2 bg-green-500 hover:bg-green-600 rounded-lg">Vote Player 1</button>
          <div id="count1" class="px-3 py-1 bg-white/6 rounded">0</div>
          <button id="vote2" class="px-4 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg">Vote Player 2</button>
          <div id="count2" class="px-3 py-1 bg-white/6 rounded">0</div>
        </div>
      </div>

      <!-- small status -->
      <div id="status" class="text-center mt-4 text-sm text-gray-300">Connecting to session...</div>
    </div>
  </main>

  <!-- Video modal / overlay (hidden initially) -->
  <div id="videoModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/60 p-4">
    <div class="w-full max-w-4xl bg-white/5 p-4 rounded-xl glass">
      <div class="flex justify-between items-center mb-3">
        <h3 class="text-lg font-semibold">Live Call</h3>
        <div class="space-x-2">
          <button id="muteBtn" class="px-3 py-1 bg-white/8 rounded">Mute</button>
          <button id="leaveBtn" class="px-3 py-1 bg-red-600 rounded">Leave</button>
        </div>
      </div>

      <div class="grid grid-cols-2 gap-4">
        <div class="flex flex-col items-center">
          <div class="text-sm mb-2">You</div>
          <video id="localVideo" autoplay playsinline muted class="w-full h-64 rounded-lg"></video>
        </div>
        <div class="flex flex-col items-center">
          <div class="text-sm mb-2">Opponent</div>
          <video id="remoteVideo" autoplay playsinline class="w-full h-64 rounded-lg"></video>
        </div>
      </div>
    </div>
  </div>

  <!-- Bottom nav -->
  <nav class="flex justify-around items-center py-3 bg-white/5">
    <button class="flex flex-col items-center">
      <img src="https://img.icons8.com/ios-filled/24/ffffff/cards.png" />
      <span class="text-xs mt-1">Cards</span>
    </button>
    <button class="flex flex-col items-center">
      <img src="https://img.icons8.com/ios-filled/24/ffffff/trophy.png" />
      <span class="text-xs mt-1">Leaderboard</span>
    </button>
    <button class="flex flex-col items-center">
      <img src="https://img.icons8.com/ios-filled/24/ffffff/video-call.png" />
      <span class="text-xs mt-1">Live</span>
    </button>
    <button class="flex flex-col items-center">
      <img src="https://img.icons8.com/ios-filled/24/ffffff/speech-bubble.png" />
      <span class="text-xs mt-1">Chat</span>
    </button>
    <button id="profileBtn" class="flex flex-col items-center">
      <img id="userAvatarBig" src="https://img.icons8.com/color/48/user-male-circle--v1.png" class="w-6 h-6 rounded-full" />
      <span class="text-xs mt-1">Profile</span>
    </button>
  </nav>

  <script>
    // ---------------- Firebase config (your project) ----------------
    const firebaseConfig = {
      apiKey: "AIzaSyAp444Vi-iivVHmY-4f0A8YFraABgknkf4",
      authDomain: "krish-d0206.firebaseapp.com",
      projectId: "krish-d0206",
      storageBucket: "krish-d0206.appspot.com",
      messagingSenderId: "669277883647",
      appId: "1:669277883647:web:59c952c78093e072a910ca",
      measurementId: "G-EQVQR43FEZ"
    };
    // ----------------------------------------------------------------

    // initialize firebase (compat)
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // UI
    const authBtn = document.getElementById('authBtn');
    const userAvatarSmall = document.getElementById('userAvatarSmall');
    const userAvatarBig = document.getElementById('userAvatarBig');
    const joinBtn = document.getElementById('joinBtn');
    const vote1 = document.getElementById('vote1');
    const vote2 = document.getElementById('vote2');
    const count1 = document.getElementById('count1');
    const count2 = document.getElementById('count2');
    const status = document.getElementById('status');

    const videoModal = document.getElementById('videoModal');
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const leaveBtn = document.getElementById('leaveBtn');
    const muteBtn = document.getElementById('muteBtn');

    // session id (URL or default)
    const params = new URLSearchParams(window.location.search);
    const SESSION_ID = params.get('session') || 'demo-match';

    let currentUser = null;
    let userRole = null; // 'player1' | 'player2' | 'viewer'
    let localStream = null;
    let pc = null;
    let isMuted = false;

    // Simple RTCPeerConnection config (add TURN servers here if you have them)
    const pcConfig = {
      iceServers: [
        { urls: "stun:stun.l.google.com:19302" }
        // add TURN here for better connectivity
      ]
    };

    // Auth
    authBtn.addEventListener('click', async () => {
      if (!auth.currentUser) {
        const provider = new firebase.auth.GoogleAuthProvider();
        try { await auth.signInWithPopup(provider); } catch (e) { alert('Login failed: ' + e.message); }
      } else {
        await auth.signOut();
      }
    });

    auth.onAuthStateChanged(user => {
      currentUser = user;
      if (user) {
        authBtn.textContent = 'Logout';
        userAvatarSmall.src = user.photoURL || '';
        userAvatarSmall.classList.remove('hidden');
        userAvatarBig.src = user.photoURL || 'https://img.icons8.com/color/48/user-male-circle--v1.png';
      } else {
        authBtn.textContent = 'Login with Google';
        userAvatarSmall.classList.add('hidden');
        userAvatarBig.src = 'https://img.icons8.com/color/48/user-male-circle--v1.png';
      }
    });

    // Reference to session doc
    const sessionRef = db.collection('sessions').doc(SESSION_ID);

    // Ensure session exists
    async function ensureSessionExists() {
      const snap = await sessionRef.get();
      if (!snap.exists) {
        await sessionRef.set({
          title: 'Demo Match',
          createdAt: firebase.firestore.FieldValue.serverTimestamp(),
          player1: null,
          player2: null,
          votes: { p1: 0, p2: 0 }
        });
      }
    }

    // Listen session changes (players, votes)
    ensureSessionExists().then(() => {
      sessionRef.onSnapshot(doc => {
        const data = doc.data();
        if (!data) return;
        document.getElementById('player1Name').textContent = data.player1 ? data.player1.displayName || 'Player 1' : 'Player 1 (empty)';
        document.getElementById('player2Name').textContent = data.player2 ? data.player2.displayName || 'Player 2' : 'Player 2 (empty)';
        count1.textContent = (data.votes && data.votes.p1) ? data.votes.p1 : 0;
        count2.textContent = (data.votes && data.votes.p2) ? data.votes.p2 : 0;
        status.textContent = `Session: ${doc.id} • Players: ${data.player1 ? '1' : '0'}/${data.player2 ? '1' : '0'}`;

        if (currentUser) {
          if (data.player1 && data.player1.uid === currentUser.uid) userRole = 'player1';
          else if (data.player2 && data.player2.uid === currentUser.uid) userRole = 'player2';
          else userRole = 'viewer';
        } else {
          userRole = null;
        }

        if (!currentUser) {
          joinBtn.textContent = 'Login to Join';
          joinBtn.disabled = false;
        } else if (userRole === 'player1' || userRole === 'player2') {
          joinBtn.textContent = 'You are in the match';
          joinBtn.disabled = false; // allow starting call
        } else {
          joinBtn.textContent = 'Join Now';
          joinBtn.disabled = false;
        }
      });
    });

    // Join logic to claim a player slot (if empty)
    async function claimSlot() {
      if (!currentUser) { alert('Login first'); return; }
      try {
        await db.runTransaction(async t => {
          const doc = await t.get(sessionRef);
          if (!doc.exists) throw 'Session missing';
          const data = doc.data();
          if (!data.player1) {
            t.update(sessionRef, { player1: { uid: currentUser.uid, displayName: currentUser.displayName, photoURL: currentUser.photoURL }});
            userRole = 'player1';
            return;
          }
          if (!data.player2 && data.player1.uid !== currentUser.uid) {
            t.update(sessionRef, { player2: { uid: currentUser.uid, displayName: currentUser.displayName, photoURL: currentUser.photoURL }});
            userRole = 'player2';
            return;
          }
          // If user already is a player, do nothing
          if (data.player1 && data.player1.uid === currentUser.uid) userRole = 'player1';
          else if (data.player2 && data.player2.uid === currentUser.uid) userRole = 'player2';
          else throw 'Match is full';
        });
        alert('Slot claimed! You can start the call by clicking JOIN NOW again.');
      } catch (err) {
        alert('Could not claim slot: ' + err);
      }
    }

    // Voting (one vote per user)
    async function castVote(playerKey) {
      if (!currentUser) return alert('Please login to vote');
      const voteRef = sessionRef.collection('votes').doc(currentUser.uid);
      try {
        await db.runTransaction(async t => {
          const voteDoc = await t.get(voteRef);
          if (voteDoc.exists) throw 'You already voted';
          const s = await t.get(sessionRef);
          const votes = s.data().votes || { p1: 0, p2: 0 };
          if (playerKey === 'p1') votes.p1 = (votes.p1 || 0) + 1;
          else votes.p2 = (votes.p2 || 0) + 1;
          t.update(sessionRef, { votes });
          t.set(voteRef, { uid: currentUser.uid, votedFor: playerKey, at: firebase.firestore.FieldValue.serverTimestamp() });
        });
        alert('Thanks for voting!');
      } catch (err) {
        alert('Vote failed: ' + err);
      }
    }

    vote1.addEventListener('click', () => castVote('p1'));
    vote2.addEventListener('click', () => castVote('p2'));

    // ------------- WebRTC (Firestore signaling) -------------
    // Firestore signaling structure:
    // sessions/{SESSION_ID}/webrtc/call -> { offer: {}, answer: {} }
    // sessions/{SESSION_ID}/webrtc/offerCandidates / answerCandidates

    const callDocRef = sessionRef.collection('webrtc').doc('call');

    async function startLocalStream() {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      localVideo.srcObject = localStream;
    }

    function createPeerConnection() {
      pc = new RTCPeerConnection(pcConfig);

      // add local tracks
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

      // when remote track arrives
      pc.ontrack = event => {
        remoteVideo.srcObject = event.streams[0];
      };

      // ICE candidate -> add to Firestore
      pc.onicecandidate = event => {
        if (event.candidate) {
          // candidate will be added in appropriate collection by caller/answerer logic
          // handled in createOffer / createAnswer functions
        }
      };
    }

    // Create offer (caller)
    async function createOfferFlow() {
      await startLocalStream();
      createPeerConnection();

      // create offer
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      // store offer in Firestore
      const offerData = { sdp: offer.sdp, type: offer.type, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
      await callDocRef.set({ offer: offerData }, { merge: true });

      // listen for answer
      callDocRef.onSnapshot(async snap => {
        const data = snap.data();
        if (!data) return;
        if (data.answer && data.answer.sdp && !pc.currentRemoteDescription) {
          const answerDesc = { type: data.answer.type, sdp: data.answer.sdp };
          await pc.setRemoteDescription(new RTCSessionDescription(answerDesc));
        }
      });

      // candidates: write local ice to offerCandidates subcollection, and listen to answerCandidates
      const offerCandidatesCol = callDocRef.collection('offerCandidates');
      pc.onicecandidate = event => {
        if (!event.candidate) return;
        offerCandidatesCol.add(event.candidate.toJSON());
      };

      const answerCandidatesCol = callDocRef.collection('answerCandidates');
      answerCandidatesCol.onSnapshot(snapshot => {
        snapshot.docChanges().forEach(async change => {
          if (change.type === 'added') {
            const c = change.doc.data();
            await pc.addIceCandidate(new RTCIceCandidate(c));
          }
        });
      });
    }

    // Create answer (callee)
    async function createAnswerFlow() {
      // get offer
      const callSnap = await callDocRef.get();
      if (!callSnap.exists || !callSnap.data().offer) {
        alert('No offer found to answer.');
        return;
      }
      await startLocalStream();
      createPeerConnection();

      const offer = callSnap.data().offer;
      await pc.setRemoteDescription(new RTCSessionDescription({ type: offer.type, sdp: offer.sdp }));

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // store answer
      const answerData = { sdp: answer.sdp, type: answer.type, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
      await callDocRef.set({ answer: answerData }, { merge: true });

      // candidates: write local ice to answerCandidates, listen to offerCandidates
      const answerCandidatesCol = callDocRef.collection('answerCandidates');
      pc.onicecandidate = event => {
        if (!event.candidate) return;
        answerCandidatesCol.add(event.candidate.toJSON());
      };

      const offerCandidatesCol = callDocRef.collection('offerCandidates');
      offerCandidatesCol.onSnapshot(snapshot => {
        snapshot.docChanges().forEach(async change => {
          if (change.type === 'added') {
            const c = change.doc.data();
            await pc.addIceCandidate(new RTCIceCandidate(c));
          }
        });
      });
    }

    // Start call: determine flow (caller/answerer) based on existing call document
    async function startCall() {
      if (!currentUser) return alert('Login first');
      // user must be a player to start a call
      if (!(userRole === 'player1' || userRole === 'player2')) {
        return alert('Only players can start the live call. Claim a player slot first.');
      }

      // show modal
      videoModal.classList.remove('hidden');
      videoModal.classList.add('flex');

      // decide: if call doc has offer already and no answer -> answer; if no offer -> create offer
      const snap = await callDocRef.get();
      const data = snap.exists ? snap.data() : {};
      try {
        if (!data || !data.offer) {
          // create offer (caller)
          await createOfferFlow();
        } else if (data.offer && !data.answer) {
          // create answer (callee)
          await createAnswerFlow();
        } else if (data.offer && data.answer) {
          // there is already finished call; for demo, we allow re-start by clearing doc then creating offer
          await cleanupCallDocs();
          await createOfferFlow();
        }
      } catch (err) {
        console.error('startCall error', err);
        alert('Call start failed: ' + err);
      }
    }

    // Hang up & cleanup
    async function hangup() {
      // close pc & tracks
      if (pc) {
        pc.getSenders().forEach(s => { try { if (s.track) s.track.stop(); } catch(e){} });
        pc.close();
        pc = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      localVideo.srcObject = null;
      remoteVideo.srcObject = null;

      // hide modal
      videoModal.classList.add('hidden');
      videoModal.classList.remove('flex');

      // cleanup signaling docs (only for demo; in production handle carefully)
      await cleanupCallDocs();
    }

    async function cleanupCallDocs() {
      const callSnap = await callDocRef.get();
      if (callSnap.exists) {
        // delete candidate subcollections
        const offerCands = await callDocRef.collection('offerCandidates').get();
        offerCands.forEach(d => d.ref.delete());
        const answerCands = await callDocRef.collection('answerCandidates').get();
        answerCands.forEach(d => d.ref.delete());
        // delete call doc
        await callDocRef.delete().catch(() => {});
      }
    }

    // Mute toggle
    muteBtn.addEventListener('click', () => {
      if (!localStream) return;
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
      muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
    });

    // Leave button
    leaveBtn.addEventListener('click', async () => {
      await hangup();
    });

    // Click handlers
    joinBtn.addEventListener('click', async () => {
      if (!currentUser) { alert('Login first'); return; }

      // if user not claimed a slot, try to claim one
      const snap = await sessionRef.get();
      const data = snap.exists ? snap.data() : {};
      if (!data.player1 || !data.player2) {
        // claim slot if empty
        await claimSlot();
        return;
      }

      // if user is player, start the call flow (caller/answerer)
      if (userRole === 'player1' || userRole === 'player2') {
        await startCall();
      } else {
        alert('You are viewer — only players can start/join call. If you want to be a player, claim an empty slot.');
      }
    });

    // safety: cleanup when closing tab
    window.addEventListener('beforeunload', async () => {
      // optional: remove user from player slot if they are leaving
    });

    // small UI note on load
    document.addEventListener('DOMContentLoaded', () => {
      status.textContent = 'Ready — connect with Firebase and login to claim a slot.';
    });

    // Developer helper: _resetDemo - clears players/votes and webrtc doc (dev only)
    window._resetDemo = async function() {
      await sessionRef.set({ title: 'Demo Match', createdAt: firebase.firestore.FieldValue.serverTimestamp(), player1: null, player2: null, votes: { p1: 0, p2: 0 } });
      const votesSnap = await sessionRef.collection('votes').get();
      const batch = db.batch();
      votesSnap.forEach(d => batch.delete(d.ref));
      await batch.commit();
      await cleanupCallDocs();
      alert('Reset done');
    };

  </script>

</body>
</html>
